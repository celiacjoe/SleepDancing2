#pragma kernel CSMain

Texture2D<float4> reader; 
Texture2D<float4> reader2;
RWTexture2D<float4> writer;
RWTexture2D<float4> writer2;
SamplerState _LinearClamp;
float _time;
float _taille;
float _forme;
float _disparition;
float _resx;
float _resy;


float2x2 m(float ang) {  float s = sin(ang); float c = cos(ang); return float2x2(c, s, -s, c); }



float getRot(float2 pos, float2 b, float ang,float2 res)
{
	float2 p = b;
	float rot = 0.0;
	for (int i = 0; i < 5; i++)
	{
		//reader.SampleLevel(_LinearClamp, uv + 0.5 / res - diff.zy, 0).x;
		rot += dot(reader.SampleLevel(_LinearClamp, frac((pos + p) /res)+ 0.5 / res,0).xy - float2(0.5,0.5), p.yx*float2(1, -1));
		p = mul(p,m(ang));
	}
	return rot / 5. / dot(b, b);
}
float4 rd(float p) {
	p = floor(p);
	return frac(sin(float4(dot(p, 45.), dot(p, 98.), dot(p, 632.),
		dot(p, 144.)))*7845.236);
}
float4 no(float p) { return lerp(rd(p), rd(p + 1.), frac(p)); }
float rd1(float p) {
	p = floor(p);
	return frac(sin(dot(p, 45.))*7845.236);
}
float no1(float p) { return lerp(rd(p), rd(p + 1.), frac(p)); }
float3 lensflares(float2 uv, float2 pos)
{
	float2 main = uv - pos;
	float2 uvd = uv * (length(uv));

	float ang = atan2(main.y, main.x);
	float dist = length(main);
	dist = pow(dist, 0.1);

	float r1 = 0.;
	float r2 = 0.;
	float r3 = 0.;
	float2 uvx = uv;
	for (int i = 0; i < 8; i++) {
		float4 ra = no(float(i + 5)*26. + _time * 0.1);
		float4 ra2 = ra * float4(0.6, 0.8, 7., 2.);
		float4 ra3 = ra * float4(20., 2.5, 0.5, 2.);
		float4 ra4 = no(float(i + 24)*26. + _time * 0.1 + 0.5);

		uvx = lerp(lerp(uv*lerp(1., ra4.x, smoothstep(0.4, 0.6, ra4.a)),
			uvx*pow(ra4.y, 2.), ra4.z), uvd, -ra2.a);
		r1 += max(0.01 - pow(length(uvx + ra2.x*pos), pow(ra2.z, 0.8)), .0)*6.0;
		r2 += max(0.01 - pow(length(uvx + (ra2.x + ra2.y)*pos), pow(ra2.z, 0.8)), .0)*5.0;
		r3 += max(0.01 - pow(length(uvx + (ra2.x + ra2.y*2.)*pos), pow(ra2.z, 0.8)), .0)*3.0;
		r1 += max(1.0 / (1.0 + 32.0*pow(length(uvx + ra3.x*pos), ra3.y)), .0)*0.25;
		r2 += max(1.0 / (1.0 + 32.0*pow(length(uvx + (ra3.x + ra3.z)*pos), ra3.y)), .0)*0.23;
		r3 += max(1.0 / (1.0 + 32.0*pow(length(uvx + (ra3.x + ra3.z*2.)*pos), ra3.y)), .0)*0.21;
	}

	return float3(r1, r2, r3);
}


[numthreads(8,8,1)]
void CSMain (uint2 id : SV_DispatchThreadID) 
{
	
	float2 f = float2(id.x,id.y);
	float2 res=float2(_resx, _resy);

	float2 uv = f / res;
	float2 pos =f;
	float ang = 2.0*3.14 / 5.;
	float2 b = float2(cos(ang), sin(ang))*10.*_taille;
	float2 v = float2(0.,0.);
	float bbMax = 0.7*res.y; bbMax *= bbMax;
	for (int l = 0; l < 4; l++)
	{
		if (dot(b, b) > bbMax) break;
		float2 p = b;
		for (int i = 0; i <5; i++)
		{

			v += p.yx*getRot(pos + p, b,ang, res);

			p = mul(p,m(ang));
		}
		b *=3.*_forme;
	}
	
	writer[id] = (reader.SampleLevel(_LinearClamp, frac((pos + v * float2(-1, 1)*2.0) /res) + 0.5 / res, 0))*(1.-0.05*_disparition);

	//float2 d2 = reader2.SampleLevel(_LinearClamp, uv + 0.5 / res, 0).xx;
	float zo = smoothstep(0.3, 0., reader2.SampleLevel(_LinearClamp, float2(1. - uv.x, 0.5) + 0.5 / res, 0).x);
	writer[id] += float4(float2(zo,zo)*(uv - 0.5)*0.025,0.,0.);
	//writer[id] = smoothstep(0.3, 0., reader2.SampleLevel(_LinearClamp, float2(1. - uv.x, 0.5) + 0.5 / res, 0))*smoothstep(0.05, 0.04, length(uv.y - 0.5));
	//writer[id] += float4(0.,0.,d2 );


	float2 uf = (uv-0.5)*2.;
	uf.x *= res.x / res.y;
	uf += reader.SampleLevel(_LinearClamp, uv + 0.5 / res, 0).xy*0.5;
	float3 flare = lensflares(uf*1.5, float2(no1(_time*1.5+596.),no1(_time*1.5+475.))*1.5);
	float3 col = smoothstep(-0.08, 0.9, pow(flare, float3(0.5,0.5,0.5)));
	writer2[id] = float4(col, 0.);
	/*
	float2 e = float2(0.001,0.);
	float d2 = reader2.SampleLevel(_LinearClamp, uv + e.xy + 0.5 / res, 0).x;
	float d3 = reader2.SampleLevel(_LinearClamp, uv - e.xy + 0.5 / res, 0).x;
	float d4 = reader2.SampleLevel(_LinearClamp, uv + e.yx + 0.5 / res, 0).x;
	float d5 = reader2.SampleLevel(_LinearClamp, uv - e.yx + 0.5 / res, 0).x;
	
	writer[id] += float4(float2(d2-d3,d4-d5) * 0.25,0.,0.);*/

}
